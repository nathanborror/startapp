{{ $name := .IOSClient.Name }}
{{ $domain := .IOSClient.BundleDomain }}
// Code generated by github.com/nathanborror/starter
// DO NOT EDIT! THIS MEANS YOU!

import Foundation

class Remote: NSObject {

    internal let endpoint: URL
    internal let session: RemoteSession
    internal let decoder: JSONDecoder
    internal let encoder: JSONEncoder

    internal var queue: [RemoteTaskID: RemoteDataTask] = [:]

    init(session: RemoteSession, endpoint: String) {
        self.endpoint = URL(string: endpoint)!
        self.session = session
        self.decoder = JSONDecoder()
        self.decoder.dateDecodingStrategy = .iso8601
        self.encoder = JSONEncoder()
        self.encoder.dateEncodingStrategy = .iso8601
    }

    func query<T: RemoteResponse>(_ query: String, args: [String: String]? = nil, token: String?, then: @escaping (RemoteResult<T>) -> Void) {
        let q = RemoteQuery(query: open(query, ext: "graphql"), variables: args)
        call(q, token: token, then: then)
    }

    func mutate<T: RemoteResponse, U: Codable>(_ query: String, input: U?, token: String?, then: @escaping (RemoteResult<T>) -> Void) {
        let q = RemoteMutation(query: open(query, ext: "graphql"), input: input)
        call(q, token: token, then: then)
    }

    func call<T: RemoteResponse, U: Codable>(_ query: U, token: String?, then: @escaping (RemoteResult<T>) -> Void) {
        let body = try? encoder.encode(query)
        var request = URLRequest(url: endpoint)
        request.httpMethod = "POST"
        request.httpBody = body
        request.cachePolicy = URLRequest.CachePolicy.reloadIgnoringLocalAndRemoteCacheData
        request.setValue("application/json; charset=utf-8", forHTTPHeaderField: "Content-Type")
        if let token = token {
            request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        }
        let task = session.dataTask(with: request) { (data, response, error) in
            guard error == nil else {
                let err = RemoteError(description: error!.localizedDescription)
                DispatchQueue.main.async { then(.failure(err)) }
                return
            }
            do {
                guard let data = data else {
                    return
                }
                let decoded = try self.decoder.decode(T.self, from: data)
                guard decoded.errors == nil else {
                    let error = decoded.errors!.first!
                    DispatchQueue.main.async { then(.failure(error)) }
                    return
                }
                DispatchQueue.main.async { then(.success(decoded)) }
            } catch {
                debugPrint("Decoding Error: \(error)")
                let err = RemoteError(description: error.localizedDescription)
                DispatchQueue.main.async { then(.failure(err)) }
            }
        }
        queue[task.taskIdentifier] = task
        task.resume()
    }

    // TODO: This shouldn't know about '{{$domain}}.{{$name}}'
    func open(_ name: String, ext: String) -> String {
        guard let path = Bundle(identifier: "{{$domain}}.{{$name}}")?.path(forResource: name, ofType: ext) else {
            return ""
        }
        guard let query = try? String(contentsOfFile: path) else {
            return ""
        }
        return query
    }
}

extension Remote: URLSessionDelegate, URLSessionDataDelegate {
}

// Operations

struct RemoteQuery: Codable {
    let query: String
    let variables: [String: String]?
}

struct RemoteMutation<T: Codable>: Codable {
    let query: String
    let variables: RemoteInput<T>?

    init(query: String, input: T? = nil) {
        self.query = query
        guard let input = input else {
            self.variables = nil
            return
        }
        self.variables = RemoteInput(input: input)
    }
}

struct RemoteInput<T: Codable>: Codable {
    let input: T
}

protocol RemoteResponse: Codable {
    var errors: [RemoteError]? { get }
}

enum RemoteResult<Value> {
    case success(Value)
    case progress(Float)
    case failure(RemoteError)

    func onSuccess(_ handler: (Value) -> ()) {
        if case .success(let v) = self { handler(v) }
    }
    func onProgress(_ handler: (Float) -> ()) {
        if case .progress(let p) = self { handler(p) }
    }
    func onFailure(_ handler: (RemoteError) -> ()) {
        if case .failure(let e) = self { handler(e) }
    }
}

// Errors

struct RemoteError: Error, Codable {
    struct Location: Codable {
        let line: Int
        let column: Int
    }
    let message: String
    let locations: [Location]?

    var localizedDescription: String {
        return message
    }
}

extension RemoteError {

    init(description: String) {
        self.message = description
        self.locations = nil
    }

    init(error: DecodingError) {
        self.message = error.localizedDescription
        self.locations = nil
    }
}
